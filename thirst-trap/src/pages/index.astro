---
import Base from "../layouts/Base.astro";
import CompanyCard from "../components/CompanyCard.astro";
import { strapi, unwrap } from "../lib/strapi";
import type { Company } from "../types/company";


/* Fetch: single grid (no category grouping) */
const res = await strapi(
  "/api/companies"
  + "?publicationState=live"
  + "&pagination[pageSize]=500"
  + "&sort=name:asc"
  + "&fields=name,slug,state,about"
  + "&populate=logo"
  + "&populate=category"
  + "&populate=tags"
  + "&populate=Evaluation"
  + "&populate=Evaluation.reasoning_tags"

);
const companies = (unwrap<any[]>(res) ?? []) as Company[];

/* Helpers for filters */
function catName(c: Company) {
  return (
    c?.category?.data?.attributes?.name ||
    c?.category?.attributes?.name ||
    c?.category?.name ||
    "uncategorized"
  );
}
function tagNames(c: Company): string[] {
  return (c?.tags?.data ?? []).map((t: any) => t?.attributes?.name).filter(Boolean);
}
function sentiment(c: Company): "good" | "bad" | "" {
  const s = c?.Evaluation?.sentiment;
  return s === "good" || s === "bad" ? s : "";
}

/* Build filter choices */
const allCategories = [...new Set(companies.map(catName))].sort();
const allTags = [...new Set(companies.flatMap(tagNames))].sort();
---

<Base>
  <h1 class="text-3xl font-bold mb-4">The Companies</h1>

  <!-- Sticky mobile-first filter bar -->
  <section class="sticky top-0 z-10 bg-base-100/95 backdrop-blur border-b border-base-200">
    <div class="grid gap-2 p-3 sm:grid-cols-2 lg:grid-cols-4">
      <input id="q" type="search" placeholder="Search companies, categories, tags…" class="input input-bordered w-full" />

      <select id="cat" class="select select-bordered w-full">
        <option value="">All categories</option>
        {allCategories.map((c) => <option value={c}>{c}</option>)}
      </select>

      <select id="tag" class="select select-bordered w-full">
        <option value="">All tags</option>
        {allTags.map((t) => <option value={t}>{t}</option>)}
      </select>

      <div class="flex gap-2">
        <select id="sent" class="select select-bordered flex-1">
          <option value="">All</option>
          <option value="bad">Bad only</option>
          <option value="good">Good only</option>
        </select>
        <select id="sort" class="select select-bordered flex-1">
          <option value="name_asc">Name A–Z</option>
          <option value="cat_asc">Category A–Z</option>
          <option value="sent_bad_first">Sentiment (bad → good)</option>
        </select>
      </div>
    </div>
  </section>

  <!-- Single grid of cards -->
  <div id="grid" class="grid gap-4 p-3 [grid-template-columns:repeat(auto-fill,minmax(16rem,1fr))]">
    {companies.map((c) => {
      const cat = catName(c);
      const tags = tagNames(c);
      const sent = sentiment(c);
      return (
        <div
          class="card-wrap contents"
          data-name={c.name.toLowerCase()}
          data-category={cat.toLowerCase()}
          data-tags={tags.join("|").toLowerCase()}
          data-sentiment={sent}
        >
          <CompanyCard company={c} />
        </div>
      );
    })}
  </div>

  <!-- Tiny filter/sort (framework-free) -->
  <script is:inline>
    const $ = (s) => document.querySelector(s);
    const $$ = (s) => Array.from(document.querySelectorAll(s));

    const iq = $("#q");
    const ic = $("#cat");
    const it = $("#tag");
    const isent = $("#sent");
    const isort = $("#sort");

    const grid = $("#grid");

    function sortCards(mode) {
      const cards = Array.from(grid.children);
      cards.sort((a, b) => {
        const an = a.dataset.name || "";
        const bn = b.dataset.name || "";
        const ac = a.dataset.category || "";
        const bc = b.dataset.category || "";
        const as = a.dataset.sentiment || "";
        const bs = b.dataset.sentiment || "";
        switch (mode) {
          case "cat_asc":        return ac.localeCompare(bc) || an.localeCompare(bn);
          case "sent_bad_first": {
            const rank = (s) => (s === "bad" ? 0 : s === "good" ? 1 : 2);
            return rank(as) - rank(bs) || an.localeCompare(bn);
          }
          case "name_asc":
          default:               return an.localeCompare(bn);
        }
      });
      cards.forEach((c) => grid.appendChild(c));
    }

    function applyFilters() {
      const q = (iq.value || "").trim().toLowerCase();
      const cat = (ic.value || "").toLowerCase();
      const tag = (it.value || "").toLowerCase();
      const sent = (isent.value || "");
      for (const el of $$(".card-wrap")) {
        const name = el.dataset.name || "";
        const category = el.dataset.category || "";
        const tags = el.dataset.tags || "";
        const sentiment = el.dataset.sentiment || "";
        const matchesQ = !q || name.includes(q) || category.includes(q) || tags.includes(q);
        const matchesCat = !cat || category === cat;
        const matchesTag = !tag || tags.split("|").includes(tag);
        const matchesSent = !sent || sentiment === sent;
        el.classList.toggle("hidden", !(matchesQ && matchesCat && matchesTag && matchesSent));
      }
    }

    let t = 0;
    const debounced = (fn) => () => { clearTimeout(t); t = setTimeout(fn, 120); };

    iq.addEventListener("input", debounced(applyFilters));
    ic.addEventListener("change", applyFilters);
    it.addEventListener("change", applyFilters);
    isent.addEventListener("change", applyFilters);
    isort.addEventListener("change", () => sortCards(isort.value));

    applyFilters();
    sortCards(isort.value);
  </script>
</Base>
