---
import Base from "../layouts/Base.astro";
import Hero from "../components/Hero.astro";
import CompanyCard from "../components/CompanyCard.astro";
import { strapi, unwrap } from "../lib/strapi";
import type { Company } from "../types/company";
import heroBanner from "../assets/hero/beautiful-banner.png";
import Faq from "../components/Faq.astro";
import heroFix from "../assets/hero-fix-me.png";
import { Image } from "astro:assets";
import StayInTouch from "../components/StayInTouch.astro";

/* CSS: import at the page level so Astro bundles it correctly */
import "../styles/hero.css";
import "../styles/company.css";

/* Fetch: single grid (no category grouping) */
const res = await strapi(
  "/api/companies"
  + "?publicationState=live"
  + "&pagination[pageSize]=500"
  + "&sort=name:asc"
  + "&fields=name,slug,about,ticker,boycott_target"
  + "&populate=logo"
  + "&populate=sector"
  + "&populate=Evaluation"
  + "&populate=Evaluation.reasoning_tags"
);
const companies = (unwrap<any[]>(res) ?? []) as Company[];

/* Helpers for filters */
function catName(c: Company) {
  return (
    c?.category?.data?.attributes?.name ||
    c?.category?.attributes?.name ||
    c?.category?.name ||
    "uncategorized"
  );
}
function tagNames(c: Company): string[] {
  return (c?.tags?.data ?? []).map((t: any) => t?.attributes?.name).filter(Boolean);
}
function sentiment(c: Company): "good" | "bad" | "" {
  const s = c?.Evaluation?.sentiment;
  return s === "good" || s === "bad" ? s : "";
}

/* Build filter choices */
const allCategories = [...new Set(companies.map(catName))].sort();
const allTags = [...new Set(companies.flatMap(tagNames))].sort();
---

<Base>
  <!-- HERO: headline is now the page H1 for SEO/AT -->
  <!-- <Hero
    bg={heroBanner}
    titleLines={["BIG", "BEAUTIFUL", "BOYCOTT"]}
    subtitle="Every dollar counts."
  >
    <div slot="actions">
      <a class="btn btn-primary" href="#grid">Browse companies</a>
      <a class="btn" href="/how-to-boycott">How to boycott</a>
    </div>
  </Hero>-->
  <!-- Full-width (within container) responsive header image -->
  <figure class="mb-6 overflow-hidden rounded-2xl shadow-sm max-h-[400px]">
    <Image
      src={heroFix}
      alt="Big Beautiful Boycott header artwork"
      widths={[640, 960, 1280, 1536, 1920]}
      sizes="(max-width: 1024px) 100vw, 1024px"
      format="webp"
      quality={75}
      loading="lazy"
      decoding="async"
      fetchpriority="high"
      class="w-full rounded-2xl shadow-sm"
    />
  </figure>


  <Faq />

  <StayInTouch />

  <!-- Keep one H1 per page; this becomes H2 -->
  <h2 class="text-3xl font-bold mb-4">The Companies</h2>

  <!-- Sticky, compact filter bar -->
  <section id="filters" class="sticky top-0 z-20 backdrop-blur bg-base-100/90 border-b border-base-200">
    <div class="mx-auto max-w-7xl px-4 py-3">
      <div id="filters-surface" class="rounded-2xl border border-base-300/70 bg-base-100/95 shadow-sm">
        <div class="p-3 sm:p-4">
          <!-- Single row, left-aligned; wraps gracefully on mobile -->
          <div class="flex flex-wrap items-center gap-2 sm:gap-3">

            <!-- Search (left, grows) -->
            <label class="relative flex-1 min-w-[16rem]">
              <svg class="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 opacity-60"
                   viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                <path d="M15.5 14h-.79l-.28-.27A6.47 6.47 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16a6.47 6.47 0 0 0 4.23-1.57l.27.28v.79L20 21.5 21.5 20l-6-6zM10 15a5 5 0 1 1 0-10 5 5 0 0 1 0 10z"/>
              </svg>
              <input id="q" type="search"
                     placeholder="Search companies or categories…"
                     class="input input-bordered input-sm w-full pl-9" />
            </label>

            <!-- Category -->
            <select id="cat" class="select select-bordered select-sm">
              <option value="">All categories</option>
              {allCategories.map((c) => <option value={c}>{c}</option>)}
            </select>

            <!-- Sort (only the four you asked for) -->
            <select id="sort" class="select select-bordered select-sm">
              <option value="name_asc">Name A–Z</option>
              <option value="name_desc">Name Z–A</option>
              <option value="cat_asc">Category A–Z</option>
              <option value="cat_desc">Category Z–A</option>
            </select>

            <!-- Count + Clear -->
            <span id="count" class="badge badge-ghost ml-auto">0 results</span>
            <button id="clear" type="button" class="btn btn-ghost btn-sm">Clear</button>
          </div>
        </div>
      </div>
    </div>
  </section>





  <!-- Single grid of cards -->
  <div id="grid" class="mt-4 grid gap-4 p-3 [grid-template-columns:repeat(auto-fill,minmax(16rem,1fr))]">

    {companies.map((c) => {
      const cat = catName(c);
      const tags = tagNames(c);
      const sent = sentiment(c);
      return (
        <div
          class="card-wrap contents"
          data-name={c.name.toLowerCase()}
          data-category={cat.toLowerCase()}
          data-tags={tags.join("|").toLowerCase()}
          data-sentiment={sent}
        >
          <CompanyCard company={c} />
        </div>
      );
    })}
  </div>

  <!-- Tiny filter/sort (framework-free) -->
  <script is:inline>
    // ---------- tiny utils ----------
    const $  = (s) => document.querySelector(s);
    const $$ = (s) => Array.from(document.querySelectorAll(s));
    const dl = (event, params = {}) => {
      (window.dataLayer = window.dataLayer || []).push({ event, ...params });
    };

    // ---------- refs ----------
    const iq = $("#q");         // search input
    const ic = $("#cat");       // category select
    const isort = $("#sort");   // sort select
    const ibar = $("#filters-surface");
    const btnClear = $("#clear");
    const badgeCount = $("#count");
    const grid = $("#grid");

    // ---------- sort ----------
    function sortCards(mode = (isort?.value || "name_asc")) {
      if (!grid) return;
      const cards = Array.from(grid.children);
      cards.sort((a, b) => {
        const an = a.dataset.name || "";
        const bn = b.dataset.name || "";
        const ac = a.dataset.category || "";
        const bc = b.dataset.category || "";
        const as = a.dataset.sentiment || "";
        const bs = b.dataset.sentiment || "";
        switch (mode) {
          case "cat_asc": {
            const byCat = ac.localeCompare(bc);
            return byCat || an.localeCompare(bn);
          }
          case "sent_bad_first": {
            const rank = (s) => (s === "bad" ? 0 : s === "good" ? 1 : 2);
            const bySent = rank(as) - rank(bs);
            return bySent || an.localeCompare(bn);
          }
          case "name_asc":
          default:
            return an.localeCompare(bn);
        }
      });
      cards.forEach((c) => grid.appendChild(c));
    }

    // ---------- filters/search + analytics ----------
    function applyFilters() {
      const q = (iq?.value || "").trim().toLowerCase();
      const cat = (ic?.value || "").toLowerCase();
      let visible = 0;

      for (const el of $$(".card-wrap")) {
        const name = (el.dataset.name || "").toLowerCase();
        const category = (el.dataset.category || "").toLowerCase();
        const tags = (el.dataset.tags || "").toLowerCase();

        const matchesQ = !q || name.includes(q) || category.includes(q) || tags.includes(q);
        const matchesCat = !cat || category === cat;
        const show = matchesQ && matchesCat;

        el.classList.toggle("hidden", !show);
        if (show) visible++;
      }

      // UI: count badge
      if (badgeCount) {
        badgeCount.textContent = `${visible} result${visible === 1 ? "" : "s"}`;
      }

      // Analytics: fire both filter + (if present) search events
      dl("filter_apply", {
        category: ic?.value || "(all)",
        sort: isort?.value || "(default)",
        total_visible: visible,
      });

      if (q) {
        dl("site_search", {
          search_term: q,
          results_count: visible,
        });
      }
    }

    // ---------- sticky bar shadow ----------
    function updateBarShadow() {
      if (!ibar) return;
      if (window.scrollY > 8) ibar.classList.add("shadow-md");
      else ibar.classList.remove("shadow-md");
    }

    // ---------- debounce helper ----------
    let t = 0;
    const debounced = (fn, ms = 150) => () => {
      clearTimeout(t);
      t = setTimeout(fn, ms);
    };

    // ---------- listeners ----------
    if (iq) iq.addEventListener("input", debounced(applyFilters));
    if (ic) ic.addEventListener("change", applyFilters);
    if (isort) isort.addEventListener("change", () => {
      sortCards(isort.value);
      // Re-emit filter_apply with updated sort context + current visible count
      // (applyFilters also emits, but keep this snappy when sort alone changes)
      const visibleNow = $$(".card-wrap:not(.hidden)").length;
      dl("filter_apply", {
        category: ic?.value || "(all)",
        sort: isort?.value || "(default)",
        total_visible: visibleNow,
      });
    });
    if (btnClear) btnClear.addEventListener("click", () => {
      if (iq) iq.value = "";
      if (ic) ic.value = "";
      applyFilters();
    });

    window.addEventListener("scroll", updateBarShadow, { passive: true });

    // ---------- initial paint ----------
    applyFilters();                 // filters + analytics for initial state
    sortCards(isort?.value);        // sort once after initial filter
    updateBarShadow();
  </script>

</Base>
