---
import Base from "../layouts/Base.astro";
import CompanyCard from "../components/CompanyCard.astro";
import { strapi, unwrap } from "../lib/strapi";
import type { Company } from "../types/company";

// LIVE only
const res = await strapi(
  "/api/companies"
  + "?publicationState=live"
  + "&pagination[pageSize]=500"
  + "&sort=category.name:asc,name:asc"
  + "&fields=name,slug,state,about"
  + "&populate=logo"
  + "&populate=category"
  + "&populate=tags"
  + "&populate=Evaluation.reasoning_tags"
);
const companies = (unwrap<any[]>(res) ?? []) as Company[];

function catName(c: Company) {
  return (
    c?.category?.data?.attributes?.name ||
    c?.category?.attributes?.name ||
    c?.category?.name ||
    "Uncategorized"
  );
}
function tagNames(c: Company): string[] {
  return (c?.tags?.data ?? []).map((t: any) => t?.attributes?.name).filter(Boolean);
}
function sentiment(c: Company): "good" | "bad" | "" {
  const s = c?.Evaluation?.sentiment;
  return s === "good" || s === "bad" ? s : "";
}

const byCategory = new Map<string, Company[]>();
for (const c of companies) {
  const k = catName(c);
  if (!byCategory.has(k)) byCategory.set(k, []);
  byCategory.get(k)!.push(c);
}
const sections = [...byCategory.entries()]
  .sort((a,b) => a[0].localeCompare(b[0]))
  .map(([k, arr]) => [k, arr.sort((x,y) => x.name.localeCompare(y.name))] as const);

// Build filter lists
const allCategories = [...new Set(companies.map(catName))].sort();
const allTags = [...new Set(companies.flatMap(tagNames))].sort();
---

<Base>
  <h1 class="text-3xl font-bold mb-4">Companies to Boycott</h1>

  <!-- Mobile-first compact filter bar -->
  <section class="sticky top-0 z-10 bg-base-100/95 backdrop-blur border-b border-base-200">
    <div class="grid gap-2 p-3 sm:grid-cols-2 lg:grid-cols-4">
      <input id="q" type="search" placeholder="Search companies, categories, tags…"
             class="input input-bordered w-full" />

      <select id="cat" class="select select-bordered w-full">
        <option value="">All categories</option>
        {allCategories.map((c) => <option value={c}>{c}</option>)}
      </select>

      <select id="tag" class="select select-bordered w-full">
        <option value="">All tags</option>
        {allTags.map((t) => <option value={t}>{t}</option>)}
      </select>

      <div class="flex gap-2">
        <select id="sent" class="select select-bordered flex-1">
          <option value="">All</option>
          <option value="bad">Bad only</option>
          <option value="good">Good only</option>
        </select>
        <select id="sort" class="select select-bordered flex-1">
          <option value="name_asc">Name A–Z</option>
          <option value="cat_asc">Category A–Z</option>
          <option value="sent_bad_first">Sentiment (bad → good)</option>
        </select>
      </div>
    </div>
  </section>

  {sections.length === 0 ? (
    <p class="p-4">No published companies yet.</p>
  ) : (
    sections.map(([category, list]) => (
      <>
        <h2 class="text-xl font-semibold mb-3 mt-6">{category}</h2>

        <!-- Grid of cards; each card is wrapped with data-* for filtering -->
        <div class="grid gap-4 [grid-template-columns:repeat(auto-fill,minmax(16rem,1fr))]" id="grid">
          {list.map((c) => {
            const cat = catName(c);
            const tags = tagNames(c);
            const sent = sentiment(c);
            return (
              <div
                class="card-wrap contents"                /* 'contents' keeps your grid sizing intact */
                data-name={c.name.toLowerCase()}
                data-category={cat.toLowerCase()}
                data-tags={tags.join("|").toLowerCase()}
                data-sentiment={sent}
              >
                <CompanyCard company={c} />
              </div>
            );
          })}
        </div>
      </>
    ))
  )}

  <!-- Filtering logic: tiny, framework-free -->
  <script is:inline>
    const $ = (s) => document.querySelector(s);
    const $$ = (s) => Array.from(document.querySelectorAll(s));

    const iq = $("#q");
    const ic = $("#cat");
    const it = $("#tag");
    const isent = $("#sent");
    const isort = $("#sort");

    let allCards = $$(".card-wrap");

    // Simple sort helpers (operate on DOM order once at load)
    function sortCards(mode) {
      const grid = $("#grid"); // Note: multiple grids exist; sort per-section
      // We have multiple section grids; sort each independently:
      $$(".grid#grid").forEach((g) => {
        const cards = Array.from(g.children);
        cards.sort((a, b) => {
          const an = a.dataset.name || "";
          const bn = b.dataset.name || "";
          const ac = a.dataset.category || "";
          const bc = b.dataset.category || "";
          const as = a.dataset.sentiment || "";
          const bs = b.dataset.sentiment || "";

          switch (mode) {
            case "cat_asc":
              return ac.localeCompare(bc) || an.localeCompare(bn);
            case "sent_bad_first": {
              const rank = (s) => (s === "bad" ? 0 : s === "good" ? 1 : 2);
              return rank(as) - rank(bs) || an.localeCompare(bn);
            }
            case "name_asc":
            default:
              return an.localeCompare(bn);
          }
        });
        cards.forEach((c) => g.appendChild(c));
      });
    }

    // Debounced filter
    let t = 0;
    function applyFilters() {
      const q = (iq.value || "").trim().toLowerCase();
      const cat = (ic.value || "").toLowerCase();
      const tag = (it.value || "").toLowerCase();
      const sent = (isent.value || "");

      allCards = $$(".card-wrap");

      for (const el of allCards) {
        const name = el.dataset.name || "";
        const category = el.dataset.category || "";
        const tags = el.dataset.tags || "";
        const sentiment = el.dataset.sentiment || "";

        const matchesQ =
          !q ||
          name.includes(q) ||
          category.includes(q) ||
          tags.includes(q);

        const matchesCat = !cat || category === cat;
        const matchesTag = !tag || tags.split("|").includes(tag);
        const matchesSent = !sent || sentiment === sent;

        const show = matchesQ && matchesCat && matchesTag && matchesSent;
        el.classList.toggle("hidden", !show);
      }
    }

    function debouncedApply() {
      clearTimeout(t);
      t = setTimeout(applyFilters, 120);
    }

    iq.addEventListener("input", debouncedApply);
    ic.addEventListener("change", applyFilters);
    it.addEventListener("change", applyFilters);
    isent.addEventListener("change", applyFilters);
    isort.addEventListener("change", () => { sortCards(isort.value); });

    // First run
    applyFilters();
    sortCards(isort.value);
  </script>
</Base>
