---
// src/pages/company/[slug].astro

import Base from "../../layouts/Base.astro";
import { strapi, unwrap, mediaUrl } from "../../lib/strapi";
import { iconForPlatform } from "../../lib/socialIcons";
import CompanyHeader from "../../components/CompanyHeader.astro";
import CompanyReasoning from "../../components/CompanyReasoning.astro";
import CompanyContact from "../../components/CompanyContact.astro";
import CompanySources from "../../components/CompanySources.astro";
import "../../styles/company.css";

export async function getStaticPaths() {
  const pageSize = 100;
  let page = 1;
  let paths: { params: { slug: string } }[] = [];

  while (true) {
    const res = await strapi(
      `/api/companies?publicationState=live&fields=slug&pagination[page]=${page}&pagination[pageSize]=${pageSize}`
    );
    const data = unwrap<any[]>(res) ?? [];
    paths.push(...data.map((c: any) => ({ params: { slug: c.slug } })));

    const meta = (res as any)?.meta?.pagination;
    if (!meta || page >= (meta.pageCount ?? 1)) break;
    page++;
  }

  return paths;
}

const { slug } = Astro.params;

/* ---------- Fetch ---------- */
const params = new URLSearchParams();
params.set("publicationState", "live");
params.set("filters[slug][$eq]", String(slug ?? ""));

// include new intro + keep about as short text
params.set("fields", "name,slug,about,intro,ticker,boycott_target");

// multiple populate keys
[
  "logo",
  "sector",
  "Evaluation",
  "Evaluation.reasoning_tags",
  "contact",
  "Reasoning",
  "Reasoning.Source",
  "ActionItems",
].forEach((key) => params.append("populate", key));

const res = await strapi(`/api/companies?${params.toString()}`);
const arr = unwrap<any[]>(res) ?? [];
const company = (Array.isArray(arr) ? arr[0] : null);

if (!company) {
  return new Response("Company not found", { status: 404 });
}

/* ---------- Logo ---------- */
const logoNode = company?.logo?.data?.attributes ?? company?.logo ?? null;
const logoUrlRaw = logoNode?.url ?? "";
const logoFormats = logoNode?.formats ?? {};
const src = logoUrlRaw ? mediaUrl(logoUrlRaw) : "";
const srcSmall = logoFormats?.thumbnail?.url ? mediaUrl(logoFormats.thumbnail.url) : "";
const srcMedium = logoFormats?.small?.url ? mediaUrl(logoFormats.small.url) : "";
const logoAlt = logoNode?.alternativeText ?? `${company.name} logo`;

const srcSet = [srcSmall && `${srcSmall} 156w`, srcMedium && `${srcMedium} 500w`, src && `${src} 779w`]
  .filter(Boolean)
  .join(", ");

/* ---------- Meta (category/tags kept for later) ---------- */
const category =
  company?.category?.name ??
  company?.category?.data?.attributes?.name ??
  null;

const tags = (company?.tags?.data ?? [])
  .map((t: any) => t?.attributes?.name ?? t?.name)
  .filter(Boolean);

/* ---------- Content ---------- */
const about: string | undefined = company.about;   // short text under name
const introHtml: string | undefined = company.intro; // long CKEditor intro
const actions: any[] = Array.isArray(company.ActionItems) ? company.ActionItems : [];

/* ---------- Reasoning + Sources (single component) ---------- */
const reasoningBlock: any | null = company.Reasoning ?? null;
const reasoningHtml: string = reasoningBlock?.content || "";
const sources: any[] = Array.isArray(reasoningBlock?.Source) ? reasoningBlock.Source : [];

/* ---------- Evaluation ---------- */
const evaln = company.Evaluation ?? null;
const sentiment: "good" | "bad" | undefined =
  evaln?.sentiment === "good" || evaln?.sentiment === "bad" ? evaln.sentiment : undefined;

const badgeClass =
  sentiment === "good"
    ? "badge badge-success normal-case"
    : sentiment === "bad"
    ? "badge badge-error normal-case"
    : "";

// reasoning tags (if you use them somewhere else)
let rawTags: any[] = [];
if (Array.isArray(evaln?.reasoning_tags)) {
  rawTags = evaln.reasoning_tags;
} else if (Array.isArray(evaln?.reasoning_tags?.data)) {
  rawTags = evaln.reasoning_tags.data.map((x: any) => x?.attributes ?? x);
}
const reasonTags = rawTags
  .map((t: any) => t && { name: t.name, color: t.color })
  .filter(Boolean);

const evalSummary = evaln?.summary ?? "";

function textColorFor(bg: string) {
  if (!bg) return "white";
  const c = bg.replace("#", "");
  const r = parseInt(c.slice(0, 2), 16);
  const g = parseInt(c.slice(2, 4), 16);
  const b = parseInt(c.slice(4, 6), 16);
  return ((0.299 * r + 0.587 * g + 0.114 * b) / 255) > 0.6 ? "black" : "white";
}

/* ---------- Contact (dynamic zone) ---------- */
const contactItems: any[] = Array.isArray(company.contact) ? company.contact : [];
const socials = contactItems.filter((c) => c?.__component === "contact.social-profile");
---

<Base>
  <article class="company prose max-w-none">
    <!-- Header -->
    <CompanyHeader company={company} />



    {/* Intro prose (CKEditor `intro` field) */}
    {introHtml && (
      <section class="mt-6">
        <div class="prose max-w-none" set:html={introHtml} />
      </section>
    )}

    {/* Evidence section (body only) */}
    <CompanyReasoning reasoning_html={reasoningHtml} />

    {Array.isArray(actions) && actions.length > 0 && (
      <section class="mt-8">
        <h2>How to Boycott</h2>
        <ul class="mt-4 space-y-4">
          {actions.map((a, idx) => (
            <li class="border-l-4 pl-3" key={idx}>
              <h3 class="font-semibold">{a.Title}</h3>
              <p class="mt-1 text-sm">{a.Description}</p>
            </li>
          ))}
        </ul>
      </section>
    )}

    <div class="prose max-w-none mt-8">
      ðŸš« Donâ€™t harass employees or patrons of this company.<br />
      ðŸš« Donâ€™t spread misinformation.
    </div>

    <CompanyContact
      companySlug={company.slug}
      companyName={company.name}
      contactItems={contactItems}
    />

    {tags.length > 0 && (
      <section class="mt-8">
        <h2>Topics</h2>
        <div class="flex flex-wrap gap-2">
          {tags.map((t) => (
            <span class="badge badge-ghost">{t}</span>
          ))}
        </div>
      </section>
    )}

    {/* Sources at the bottom */}
    <CompanySources sources={sources} />
  </article>
</Base>
